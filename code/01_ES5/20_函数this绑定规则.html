<!--
 * @Autor: lcl
 * @Version: 2.0
 * @Date: 2022-10-26 09:34:26
 * @LastEditors: lcl
 * @LastEditTime: 2022-10-26 09:42:19
 * @Description: lcl
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>
<script>
  // 规则一：默认绑定
  //   1.普通的函数被独立的调用
  // function foo() {
  //   console.log('foo:', this);
  // }
  // foo();
  // 2.函数定义在对象中, 但是独立调用
  // var obj = {
  //   name: 'why',
  //   bar: function () {
  //     console.log('bar:', this);
  //   },
  // };
  // var baz = obj.bar;
  // baz();
  //     3.高阶函数：传函数
  // function test(fn) {
  //   fn();
  // }
  // test(obj.bar);
  //     4.严格模式下, 独立调用的函数中的this指向的是undefined
  // 绑定二：隐式绑定；
  //     1.函数定义在对象中, 但是独立调用
  // function foo() {
  //   console.log('foo函数:', this);
  // }
  // var obj = {
  //   bar: foo,
  // };
  // obj.bar();
  // 绑定三：显示绑定；
  //     1.apply
  //       第一个参数: 绑定this
  //       第二个参数: 传入额外的实参, 以数组的形式
  // foo.apply('apply', ['kobe', 30, 1.98]);

  //     2.call
  //       第一个参数: 绑定this
  //       参数列表: 后续的参数以多参数的形式传递, 会作为实参

  //     3.bind函数：返回新的函数进行调用
  // function foo(name, age, height, address) {
  //   console.log('foo:', this);
  //   console.log('参数:', name, age, height, address);
  // }
  // var obj = { name: 'why' };
  //     // 需求: 调用foo时, 总是绑定到obj对象身上(不希望obj对象身上有函数)
  //     // 1.bind函数的基本使用
  // var bar = foo.bind(obj);
  // bar(); // this -> obj
  //     // 2.bind函数的其他参数(了解)
  // var bar = foo.bind(obj, 'kobe', 18, 1.88);
  // bar('james');
  //     绑定四：new绑定；
  //  4.构造函数：
  /*
        1.创建新的空对象 foo{}
        2.将this指向这个空对象
        3.执行函数体中的代码
        4.没有显示返回非空对象时, 默认返回这个对象
  */
  // function foo() {
  //   console.log(this);
  //   this.name = 'why';
  //   console.log('foo函数:', this);
  // }
  // const p = new foo();

  // 绑定四：特殊绑定情况
  //     1.情况一: 显式绑定null/undefined, 那么使用的规则是默认绑定
  // function foo() {
  //   console.log('foo:', this);
  // }
  // foo.apply('abc');
  // foo.apply(null);
  // foo.apply(undefined);

  //     2.情况二: 间接函数引用：那么使用的规则是默认绑定
  // var obj1 = {
  //   name: 'obj1',
  //   foo: function () {
  //     console.log('foo:', this);
  //   },
  // };
  // var obj2 = {
  //   name: 'obj2',
  // };
  // // {}[]()
  // // obj2.foo = obj1.foo
  // // obj2.foo()
  // (obj2.foo = obj1.foo)();
</script>
