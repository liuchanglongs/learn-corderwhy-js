<!--
 * @Autor: lcl
 * @Version: 2.0
 * @Date: 2022-10-11 14:01:11
 * @LastEditors: lcl
 * @LastEditTime: 2022-10-13 21:31:20
 * @Description: lcl
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>

<script>
  /*
   * @Autor: lcl
   * @Version: 2.0
   * @Date: 2022-10-11 14:01:11
   * @LastEditors: lcl
   * @LastEditTime: 2022-10-11 14:15:06
   * @Description: lcl
   */
  // 设计要符合规范：Promise
  // 1、架构设计
  // 2、状态设计：pending、fulfilled、rejected
  // 3、resolve、reject函数设计
  // 4、实例方法then方法的实现
  //    一、优化实例的then调用多次，最后的会把前面的覆盖
  //        - 存值存成数组
  //    二、优化通过定时器调用实例的then，无法执行
  //        - 不为pending状态，then里面直接执行resolve、reject
  //    三、实例方法then链式调用\异常处理
  //    四、实例方法catch异常处理
  //    五、finally方法实现

  // promise的3个状态
  const pending = 'pending';
  const fulfilled = 'fulfilled';
  const rejected = 'rejected';
  // 控制状态的遍历

  const executeFnWidthCatch = function (fn, data, resolve, reject) {
    try {
      const res = fn(data);
      resolve(res);
    } catch (error) {
      // console.log(error);
      reject(error);
    }
  };

  class Lpromise {
    constructor(fn) {
      this.onfulfilled = [];
      this.onrejected = [];
      this.status = pending;
      // resolve出去的数据
      this.value = undefined;
      // reject出去的数据
      this.reason = undefined;

      const resolve = (...val) => {
        // 加入微任务：让实例的then方法在执行
        if (this.status == pending) {
          this.value = val;
          queueMicrotask(() => {
            // fulfilled\reject状态不执行
            if (this.status !== pending) return;
            this.status = fulfilled;
            this.onfulfilled.forEach((fn) => {
              fn(...this.value);
            });
          });
        }
      };

      const reject = (...err) => {
        // 加入微任务：让实例的then方法在执行
        if (this.status == pending) {
          this.reason = err;
          queueMicrotask(() => {
            // fulfilled\reject状态不执行
            if (this.status !== pending) return;
            // console.log('->', this);

            this.status = rejected;
            this.onrejected.forEach((fn) => {
              fn(...this.reason);
            });
          });
        }
      };

      try {
        fn(resolve, reject);
      } catch (error) {
        reject(error);
      }

      this.then = function (onfulfilled, onrejected) {
        // 实现catch
        const errFn = (err) => {
          // console.log(err);
          throw err;
        };
        onrejected = onrejected || errFn;
        // finally
        const fulFn = (value) => {
          // throw err;
          return value;
        };
        onfulfilled = onfulfilled || fulFn;

        return new Lpromise((resolve, reject) => {
          // 1、当已经为fulfilled、rejected状态的时候，直接执行
          if (this.status === fulfilled && onfulfilled) {
            executeFnWidthCatch(onfulfilled, ...this.value, resolve, reject);
          }
          if (this.status === rejected && onrejected) {
            executeFnWidthCatch(onrejected, ...this.reason, resolve, reject);
          }

          if (this.status === pending) {
            // 防止多个实例的调用只执行最的then
            if (onfulfilled)
              this.onfulfilled.push(() => {
                executeFnWidthCatch(
                  onfulfilled,
                  ...this.value,
                  resolve,
                  reject
                );
              });

            if (onrejected)
              this.onrejected.push(() => {
                executeFnWidthCatch(
                  onrejected,
                  ...this.reason,
                  resolve,
                  reject
                );
              });
          }
        });
      };

      this.catch = function (onrejected) {
        return this.then(undefined, onrejected);
      };

      this.finally = function (onfinally) {
        this.then(
          (value) => {
            onfinally(value);
          },
          (value) => {
            onfinally(value);
          }
        );
        // this.then(onfinally, onfinally);
      };
    }

    static reject(rejectData) {
      return new Lpromise((resolve, reject) => reject(rejectData));
    }
    static resolve(resolveData) {
      return new Lpromise((resolve) => resolve(resolveData));
    }
    static all(promises) {
      const arry = [];
      return new Lpromise((reslove, reject) => {
        promises.forEach((fn) => {
          fn.then(
            (res) => {
              arry.push(res);
              if (arry.length === promises.length) {
                reslove(arry);
              }
            },
            (err) => {
              reject(err);
            }
          );
        });
      });
    }

    static allsettled(promises) {
      const arry = [];
      return new Lpromise((reslove, reject) => {
        promises.forEach((fn) => {
          fn.then(
            (res) => {
              arry.push({ value: res, statu: fulfilled });
              if (arry.length === promises.length) {
                reslove(arry);
              }
            },
            (err) => {
              arry.push({ value: err, statu: rejected });
              if (arry.length === promises.length) {
                reslove(arry);
              }
            }
          );
        });
      });
    }
  }

  const p1 = new Lpromise((reslove, resject) => {
    setTimeout(() => {
      resject('aaa');
    }, 1000);
  });

  const p2 = new Lpromise((reslove, resject) => {
    setTimeout(() => {
      // resject('bbb');
      reslove('bbb');
    }, 1000);
  });

  const p3 = new Lpromise((reslove, resject) => {
    setTimeout(() => {
      reslove('ccc');
    }, 1000);
  });

  // Lpromise.all([p1, p2, p3])
  //   .then(
  //     (res) => {
  //       console.log(res);
  //     }
  //     // (err) => {
  //     //   console.log('err:', err);
  //     // }
  //   )
  //   .catch((err) => {
  //     console.log(err);
  //   });

  Lpromise.allsettled([p1, p2, p3])
    .then((res) => {
      console.log(res);
    })
    .catch((err) => {
      console.log(err);
    });
</script>
