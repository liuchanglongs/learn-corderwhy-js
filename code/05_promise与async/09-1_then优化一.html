<!--
 * @Autor: lcl
 * @Version: 2.0
 * @Date: 2022-10-11 14:01:11
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2025/4/2
 * @Description: lcl
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>

<script>
  /*
   * @Autor: lcl
   * @Version: 2.0
   * @Date: 2022-10-11 14:01:11
   * @LastEditors: lcl
   * @LastEditTime: 2022-10-11 14:15:06
   * @Description: lcl
   */
  // 设计要符合规范：Promise
  // 1、架构设计
  // 2、状态设计：pending、fulfilled、rejected
  // 3、resolve、reject函数设计
  // 4、实例方法then方法的实现
  //    一、优化实例的then调用多次，最后的会把前面的覆盖
  //        - 存值存成数组
  //    二、优化通过定时器调用实例的then，无法执行
  //        - 不为pending状态，then里面直接执行resolve、reject

  // promise的3个状态
  const pending = "pending";
  const fulfilled = "fulfilled";
  const rejected = "rejected";
  // 控制状态的遍历
  let status = pending;

  // resolve出去的数据
  let value = undefined;
  // reject出去的数据
  let reason = undefined;

  class Lpromise {
    constructor(fn) {
      this.onfulfilled = [];
      this.onrejected = [];

      const resolve = (...val) => {
        console.log(val, this.onfulfilled);
        if (status === pending) {
          // 加入微任务：让实例的then方法在执行
          value = val;
          queueMicrotask(() => {
            // fulfilled\reject状态不执行
            if (status !== pending) return;
            status = fulfilled;
            this.onfulfilled.forEach((fn) => {
              fn(...value);
            });
          });
        }
      };

      const reject = (...err) => {
        if (status === pending) {
          // 加入微任务：让实例的then方法在执行
          reason = err;
          queueMicrotask(() => {
            // fulfilled\reject状态不执行
            if (status !== pending) return;
            status = rejected;
            this.onrejected.forEach((fn) => {
              fn(...reason);
            });
          });
        }
      };

      fn(resolve, reject);

      this.then = function (onfulfilled, onrejected) {
        // 1、当已经为fulfilled、rejected状态的时候，直接执行
        // debugger;
        console.log(status);
        if (status === fulfilled && onfulfilled) {
          onfulfilled(...value);
        }
        if (status === rejected && onrejected) {
          onrejected(...reason);
        }
        if (status === pending) {
          // console.log(status, value);
          // 防止多个实例的调用只执行最的then
          this.onfulfilled.push(onfulfilled);
          this.onrejected.push(onrejected);
        }
      };
    }
  }
  const promise = new Lpromise((resolve, reject) => {
    resolve("resolve");
    // reject("reject");
  });

  // promise.then(
  //   (res) => {
  //     console.log(1, res);
  //   }
  //   // (err) => {
  //   //   console.log(1, err);
  //   // }
  // );

  // promise.then(
  //   (res) => {
  //     console.log(2, res);
  //   },
  //   (err) => {
  //     console.log(2, err);
  //   }
  // );
  // promise.then(
  //   (res) => {
  //     console.log(2, res);
  //   },
  //   (err) => {
  //     console.log(2, err);
  //   }
  // );

  setTimeout(() => {
    promise.then(
      (res) => {
        console.log(3, res);
      },
      (err) => {
        console.log(3, err);
      }
    );
  }, 0);
  // setTimeout(() => {
  //   promise.then(
  //     (res) => {
  //       console.log(4, res);
  //     },
  //     (err) => {
  //       console.log(4, err);
  //     }
  //   );
  // }, 0);
  // console.log(promise);

  // js的promise
  const promise1 = new Promise((resolve) => {
    // resolve('resolve');
  });
  // promise1.then(
  //   (value) => {
  //     console.log(1, value);
  //   },
  //   (reason) => {}
  // );

  // promise1.then(
  //   (value) => {
  //     console.log(2, value);
  //   },
  //   (reason) => {}
  // );

  // setTimeout(() => {
  //   promise1.then(
  //     (value) => {
  //       console.log(3, value);
  //     },
  //     (reason) => {}
  //   );
  // }, 0);
  // setTimeout(() => {
  //   promise1.then(
  //     (value) => {
  //       console.log(4, value);
  //     },
  //     (reason) => {}
  //   );
  // }, 0);
  // setTimeout(() => {
  //   promise1.then(
  //     (value) => {
  //       console.log(5, value);
  //     },
  //     (reason) => {}
  //   );
  // }, 0);
</script>
