<!--
 * @Author: lcl
 * @Date: 2025/3/24
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<script>
  /**
   * 让下面的函数一次执行，最后返回一个数组. 模拟async await
   *  1. 需要一个生成器函数，控制运行createGeneratorFunction
   *  2. run 函数：返回一个promise，里面递归执行生成器
   *    next()的返回值来判断，是否继续递归
   * */
  const run = (generatorFn) => {
    return new Promise((resolve, reject) => {
      const iterator = generatorFn()
      const deep = (arg, next = 'next') => {
        try {
          console.log("arg:", arg); // undefined ; 这是异步获取的数据 1; '这是异步获取的数据 2'
          const iteratorData = iterator[next](arg);
          const { done, value } = iteratorData;
          console.log("iteratorData:", done, value);// false , Promise; false , Promise; true, [ '这是异步获取的数据 1', '这是异步获取的数据 2' ]

          if (!done) {
            value.then(res => {
              deep(res)
            }, err => {
              deep(err, 'throw')
            })
          } else {
            resolve(value)
          }
        } catch (error) {
          reject(error)
        }
      }
      deep()
    })
  }

  const createGeneratorFunction = (arryPromise) => {

    const results = []
    return function* () {
      try {
        for (const fn of arryPromise) {
          const result = yield fn();
          results.push(result);
        }
        return results
      } catch (error) {
        console.log(error);

        return error
      }
    }
  }



  // 模拟第一个异步操作的函数，返回一个 Promise
  function fetchData1() {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('这是异步获取的数据 1');
      }, 2000);
    });
  }

  // 模拟第二个异步操作的函数，返回一个 Promise
  function fetchData2() {
    return new Promise((resolve) => {
      // setTimeout(() => {
      resolve('这是异步获取的数据 2');
      // }, 1500);
    });
  }


  run(createGeneratorFunction([fetchData1, fetchData2])).then(res => {
    console.log("结果：", res);
  })



</script>
</body>

</html>