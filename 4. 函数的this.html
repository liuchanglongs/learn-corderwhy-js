<!--
 * @Author: lcl
 * @Date: 2025/3/24
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      //   "use strict";
      //   规则一：默认绑定
      //   1.普通的函数被独立的调用
      //   function foo() {
      //     console.log("foo:", this); // window
      //   }
      //   foo();
      //   // 2.函数定义在对象中, 但是独立调用
      //   var obj = {
      //     name: "why",
      //     bar: function () {
      //       console.log("bar:", this);
      //     },
      //   };
      //   var baz = obj.bar;
      //   baz(); // window
      //   // 3.高阶函数：传函数
      //   function test(fn) {
      //     fn();
      //   }
      //   test(obj.bar); // window
      //   // 4.严格模式下, 独立调用的函数中的this指向的是undefined

      //   //   绑定二：隐式绑定；
      //   // 1.函数定义在对象中, 但是独立调用
      function foo() {
        console.log("foo函数:", this);
      }
      //   var obj = {
      //     bar: foo,
      //   };
      //   obj.bar();

      //   function foo() {
      //     this.name = "why";
      //     console.log("foo函数:", this);
      //   }
      //   new foo();
      // 绑定二：隐式绑定；
      // 1.函数定义在对象中, 但是独立调用
      //   function foo() {
      //     console.log("foo函数:", this);
      //   }
      //   var obj = {
      //     bar: foo,
      //   };
      //   obj.bar();

      // 3.bind函数：返回新的函数进行调用
      //   function foo(name, age, height, address) {
      //     console.log("foo:", this);
      //     console.log("参数:", name, age, height, address);
      //   }
      //   var obj = { name: "why" };
      //   // 需求: 调用foo时, 总是绑定到obj对象身上(不希望obj对象身上有函数)
      //   // 1.bind函数的基本使用
      //   // var bar = foo.bind(obj)
      //   // bar() // this -> obj
      //   // 2.bind函数的其他参数(了解):会把返回函数bar的参数放到最后
      //   var bar = foo.bind(obj, "kobe", 18, 1.88);
      //   bar("james");

      //   function foo() {
      //     this.name = "why";
      //     console.log("foo函数:", this);
      //   }
      //   new foo();

      // 1.情况一: 显式绑定null/undefined, 那么使用的规则是默认绑定
      //   function foo() {
      //     console.log("foo:", this);
      //   }
      //   foo.apply("abc");
      //   foo.apply(null);
      //   foo.apply(undefined);

      // 2.情况二: 间接函数引用：那么使用的规则是默认绑定
      //   var obj1 = {
      //     name: "obj1",
      //     foo: function () {
      //       console.log("foo:", this);
      //     },
      //   };
      var obj2 = {
        name: "obj2",
      };
      //   // {}[]()
      //   obj2.foo = obj1.foo;
      //   obj2.foo();
      //   (obj2.foo = obj1.foo)();

      //   function fn() {
      //     (function l() {
      //       console.log(this);
      //     })();
      //     console.log(this);
      //   }
      //   fn.apply(obj2);
      //   obj2.fn = fn;
      //   obj2.fn();
      //   var obj = { foo: foo };
      //   obj.foo.apply("abc");
      //   obj.foo.call("abc");

      //   var obj = {
      //     name: "why",
      //     foo: function () {
      //       console.log("foo:", this);
      //       console.log("foo:", this === obj);
      //     },
      //   };
      //   new obj.foo();

      //   function foo() {
      //     this.name = "why";
      //     console.log("foo函数:", this);
      //   }
      //   new foo();

      //   var bar = foo.bind("aaa");
      var obj = {
        name: "why",
        // baz: bar,
      };
      //   obj.baz();

      //   function foo() {
      //     console.log("foo:", this);
      //   }
      //   var bindFn = foo.bind("aaa");
      //   new bindFn();

      //   function foo() {
      //     console.log("foo:", this);
      //   }
      //   var bindFn = foo.bind("aaa");
      //   bindFn.call("bbb");

      // var obj1 = {
      //   name: "obj1",
      //   foo: function () {
      //     (function () {
      //       console.log("function1", this); // this-->window
      //     })();
      //     setTimeout(function () {
      //       console.log("setTimeout1:", this); // this-->window
      //       (function () {
      //         console.log("function2", this); // this-->window
      //       })();
      //     }, 100);
      //     console.log("foo:", this); // this-->obj1
      //   },
      // };
      // obj1.foo.call(obj1);

      var obj1 = {
        name: "obj1",
        foo: function () {
          (() => {
            console.log("function1", this); // this-->obj1
          })();
          setTimeout(() => {
            console.log("setTimeout1:", this); // this-->obj1
            (() => {
              console.log("function2", this); // this-->obj1
            })();
          }, 100);
          setTimeout(() => {
            console.log("setTimeout2:", this); // this-->obj1
          }, 100);
          setInterval(() => {
            // console.log("setTimeout2:", this); // this-->obj1
          }, 1000);
          console.log("foo:", this); // this-->obj1
        },
      };
      obj1.foo.call(obj1);
    </script>
  </body>
</html>
